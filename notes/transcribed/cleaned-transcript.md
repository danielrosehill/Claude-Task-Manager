# Cleaned Transcript

**Title:** Task Manager for Cloud Code: Context and Planning Notes
**Date:** 28 Dec 2025 20:09

---

Okay, the purpose of this repository is to gather context, planning notes for a task manager for cloud code that I think will be, you know, there's a lot of these projects out there. I've tried a couple of them. I really like open code; it's very, very nice, very good project.

So these notes are just—they could just be notes for could be tooling that I look into creating, or preferably, just find something that aligns with the kind of pain points I'm describing, but either way, I figured it would be good to just kind of specify what those are.

## Workflow and Pain Points

So, if I'm using cloud code for developing a big repository, I'm currently trying to finish my—it's a fork of a home inventory project. That's proven very useful. And using cloud code to do a lot of the changing over of stuff.

And this is great. Generally, a high reasoning model like Opus is very reliable, I find, on specific tasks, but that's where it becomes challenging.

My method that I've kind of refined over the past year for projects like this is capturing tasks in voice format, which is why I'm using it now for these notes. And I'll kind of say, this is exactly what's wrong, or this is exactly what we want to add. And I'll get a kind of reformatted version that defines a task.

Now the challenge is that currently, I can kind of tee these up on a notepad in different tabs, and they're ready to go. But the promise of agentic co-generation and automation and AI is that I think if you're prepared to accept this level of risk, it even seems silly to have to, even if the co-generation is happening all programmatically, for me to have to spend my afternoon sitting here watching, is foolish. Now, the challenge really is that the co-generation tools tend to work—tend to want to work.

I feel like they're being used for very different projects. Like, this project is a—it's an open source home project and I'm fine with the code not being, you know, perfect. It's something that I just want for my own use. It's very different from using these tools on, let's say, a production environment where you're clearly generating buggy code is far from acceptable.

But I think there's a very valid use for both. And in this context, where I'm just kind of saying, okay, look, these are all the things that I need, this is what's wrong, change this, add this. I'm—I'm fine going in YOLO mode. YOLO mode meaning accept everything, you know, try not to break it. If you do break something, try to fix it. And that's the mode that I actually want.

I'd much rather have that than—than having to, you know, hit confirmation buttons and say yes, approve bash commands, approve this, approve deployment. So getting into that kind of fully autonomous mode is the goal. Now when I define my tasks, the kind of workflow probably that would make the most sense to me—I'm looking at Homebox now or where my stuff is, is the name that I forked it to. And I could easily go through the site and say, okay, storage units page, the menu is a mess; that looks really ugly. Let's lay it out with, you know, a horizontal bar and let's have these nested. Mostly very agentic coding stuff. I feel like it's come to make me really love working on UI because it's mostly UI things that are just points of friction and—and just getting those fixed. Now, here's a challenge with co-generation tools. They work very well in short bursts, as I think I already mentioned. So you come up with a modular task, you say run, and it finishes the task.

## Context and Sequential Task Management

What—and that's related to context because from the very first token, the very first words, you're going to be—you're running down the context window.

So really the challenge I think in getting to the—in—in—if I have a workflow as I define, where I go through a website and I say, okay, here is a list of eight things. Usually it's, let's say, four or five different things that I can identify. The—what I've seen a lot of the task managers do is try to kind of, you know, cloud supports this through, I think, Git work trees, and I've definitely tried this out, but I think it works very badly. And that is spawning multiple workers. So I can say, okay, here are my six things, and the temptation, I guess, is, okay, let's—let's spawn six workers to work on the six features in parallel, and we'll use like a Git work tree. And that in theory gets the work done a lot quicker, but here's why I don't think it's a good idea. Number one, you've got, you know, enormous potential for conflicts because you've got like six people working on the code base simultaneously. And even with Git, it's a headache in the making. The second reason is that you're much likelier to hit rate limiting that way. And not just maybe explicit rate limiting, but subtle rate limiting that's, you know, that Anthropic sees you're—you're trying to use six workers in parallel and it doesn't like that.

So there's a number—for—for that—for those reasons, the type of task management system I'm looking for is actually not that. It's a—what's the word? Not parallel—sequential. I think that's right. Sequential. Sequential task queuing. Simply meaning all I'm looking to automate away is the process by which I see—I load up—I—I load up a task. I see it's done, and then we start the next task. And that's where I still do this manually because I know that that's the most reliable way I've seen to make sure that we start a new turn when we can start a new turn, so we remove the context trail.

And that's where I want to have a task manager automated. So the—in summary, the objective of the framework that I'm looking to create or find, either or, is I go through a website, or project. Let's—let's take my voice—my voice notepad for an example, which I made a lot of progress on last week, and I'm really happy with because it's—I'm using it literally all the time now. I can say, okay, looking at this, yeah, we've still got the emojis here in the prompt stack. There's a UX issue here that the shading should be—should encompass those things. In what else is not working? TTS announcements. I started that, but they're not actually working. Debug that. So what might be the most interesting task management system would be if we take that queue that I came up with just there on the fly. You can divide that into discrete tasks in categories. We have debugging, we have UI UX, we have feature editions.

Now what would be very cool and very interesting would be an agent that actually kind of took in my firehose as such, saying, okay, these are all the things that Daniel wants to work on in his voice notepad app. Let's create specific tasks from that. Let's categorize them. This is—this is debugging, this is UI UX, this is CSS. Now the question is what would be the most logical way to approach that task list sequentially? You know, should you start with feature editions? I would probably say the logic I'd wish to have in an agent would be anything that's broken. Start by fixing it. CSS maybe, and then actually potentially even pushing the feature editions to the end of that queue, so that we can focus firstly always on getting the existing code stable, and then we can add new stuff, but don't add new stuff before the existing stuff is fixed. I think that's probably the the best practice there. So it would be taking in, dividing it into cue, and then whether we're—whether the actual co-generation agent is cloud code, or whether it's, you know, GLM 4.7, that tooling aspect is I very much like the philosophy baked into Open Code, that the orchestration and management layer should be separated, so that you might find, you know, you can try out different ones. So that's the idea for my queuing system. I need to kind of transcribe this and get it into some more rigid context, but I think that would be—that's exactly what I'm looking for, basically.
