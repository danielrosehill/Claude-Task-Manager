# Verbatim Transcript

**Title:** Planning Notes: Task Manager for Cloud Code
**Date:** 28 Dec 2025 20:07

---

Okay, the purpose of this repository is to gather context planning notes for a task manager for cloud code uh that I think will be um, you know, there's a lot of these projects out there. Um, I've tried a couple of them. I really like Open Code. It's very, very nice, very good project. So, these notes are just, they could just be notes for um, it could be tooling that I uh look into creating or preferably just find something that aligns with um the kind of pain points I'm describing. But either way, I figured it would be good to just kind of specify what those are. So, if I'm using Cloud Code for developing a big repository, I'm currently trying to finish um, my, it's a fork of a home inventory project that's proven very useful. And using Cloud Code to do a lot of the, the changing over of stuff. And this is great. Generally, a higher reasoning model like Opus is very reliable I find on specific tasks, but that's where it becomes challenging. My method that I've kind of refined over the past year for projects like this is uh capturing tasks in voice format, which is why I'm using it now for these notes. And I'll kind of say this is exactly what's wrong or this is exactly what we want to add. And I'll get a kind of reformatted version that defines a task. Now, the challenge is that currently I can kind of tee these up on a notepad in different tabs and they're ready to go. But I the promise of agentic co-generation and automation and AI is that, I think if you're prepared to accept this level of risk, it even seems silly to have to even if the co-generation is happening all programmatically, for me to have to spend my afternoon sitting here watching is is foolish. Um, now the challenge really is that the co-generation tools tend to work, tend to want to work. I feel like they're being used for very different projects. Like this project is a is it's an open source home project and I'm fine with the code not being per uh, you know, perfect. It's something that I just want for my own use. It's uh very different from using these tools on, let's say, a production environment where you're clearly generating buggy code is is is far from acceptable. Um, but I think there's a very valid use for, for both. And in this context, where I'm just kind of saying, okay, look, these are all the things that I need. This is what's wrong. Change this, add this. I'm, I'm fine going in YOLO mode. YOLO mode meaning, accept everything. Um, you know, try not to break it. If you do break something, try to fix it. Uh, and that's the mode that I actually want. I'd much rather have that than, than having to, you know, hit confirmation buttons and say, yes, approve bash commands, approve this, approve deployment. So, getting into that kind of fully autonomous mode is the goal. Um, now when I define my tasks, the kind of workflow probably that would make the most sense to me, I'm looking at homebox now or where my stuff is I, is the name that I forked it to. And I could easily go through the site and say, okay, storage units page, uh, the menu's a mess. That looks really ugly. Let's lay it out with um, you know, a horizontal bar and let's have these nested. Mostly very agentic coding stuff. I feel like it's come to make me really love uh working on UI because it's mostly you, you, UI things that are just points of friction and and just getting those fixed. Now, here's the challenge with co-generation tools. Uh, they work very well in short bursts as I, I think I already mentioned. Um, so you come up with a modular task, you say run, and it finishes the task. Um, what, and that's related to context because from the very first token, the very first word, you're going to be, you're running down the context window. So, really the challenge I think in getting to the in in if if I have a workflow as I define, where I go through a website and I say, okay, here is a list of eight things. Usually it's, let's say, four or five different things that I can identify. The, what I've seen a lot of the task managers do is try to kind of, you know, Cloud supports this through, I think, Git work trees. And I've definitely tried this out, but I think it works very badly. And that is spawning multiple workers. So, I can say, okay, here are my six things. And the temptation, I guess, is, okay, let's let's spawn six workers to work on the six features in parallel, and we'll use like a Git work tree. And that in theory gets the work done a lot quicker, but here's why I don't think it's a good idea. Number one, you've got, you know, enormous potential for um, for conflicts because you've got like six people working on the code base simultaneously. And even with Git, it's it's a headache in the making. The second reason is that you're much likelier to hit rate limiting that way. And not just maybe explicit rate limiting, but subtler rate limiting that's, you know, the Anthropic sees you're, you're trying to use six workers in parallel and it doesn't like that. So, there's a number of for for that, for those reasons, the type of task management system I'm looking for is actually not that. It's a uh, what's the word? Not parallel, sequential. I think that's right, sequential. Sequential task queuing. Simply meaning all I'm looking to automate away is the process by which I see, I load up a, I I load up a task, I see it's done, and then we start the next task. And that's where I still do this manually because I know that um, that's the most reliable way I've seen to make sure that we start a new turn when we can start a new turn, so we remove the context trail. Um, and that's where I want to have a task manager automated. So, in the in summary, the the objective of the framework that I'm looking to create or find, either or, is I go through a website or project, let's let's take my voic note, my voice notepad for an example, uh which I made a lot of progress on last week and I'm really happy with because it's, I'm using it literally all the time now. Uh I can say, okay, looking at this, yeah, we still got the emojis here in the prompt stack. Um, there's a UX issue here that the shading should be should encompass those things. Um, in what else is not working? TTS announcements, I started that but they're not actually working. Debug that. So, what might be the most interesting task management system would be if we take that queue that I came up with just there on the fly. You can divide that into discrete tasks in categories. We have debugging, we have UI UX, we have feature additions. Now, what would be very cool and very interesting would be an agent that actually kind of took in my firehose as such, saying, okay, these are all the things that Daniel wants to work on in his voice notepad app. Let's create specific tasks from that. Let's categorize them. This is, this is debugging, this is UI UX, this is CSS. Now, the question is, what would be the most logical way to approach that task list sequentially? You know, should you start with feature additions? I would probably say the logic I'd wish to have in an agent would be anything that's broken, start by fixing it. Um, CSS maybe, and then actually potentially even pushing the feature additions to the end of that queue so that we can focus firstly always on getting the existing code uh stable. And then we can add new stuff, but don't add new stuff before the existing stuff is fixed. I think that's probably the the best practice there. So, it would be taking it, taking it in, dividing it into a queue, and then whether we, whether the actual co-generation agent is uh cloud code or whether it's, you know, GLM 4.7, that tooling aspect is I very much like the philosophy baked into Open Code that the orchestration and management layer should be separated so that you might find, you know, you can try out different ones. So that's the idea for my queuing system. I need to kind of transcribe this and get it into some more uh rigid context. But I think that would be, that's exactly what I'm looking for, basically.
